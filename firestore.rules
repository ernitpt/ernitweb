rules_version = '2';
service cloud.firestore {
  match /b/{bucket}/o {
    match /{allPaths=**} {
      allow read;
      allow write: if request.auth != null;
    }
  }
  match /databases/{database}/documents {

    /** =====================
     * üîß HELPERS
     * ===================== **/
    function userDoc(uid) {
      return get(/databases/$(database)/documents/users/$(uid));
    }

    function partnerUserDoc(uid) {
      return get(/databases/$(database)/documents/partnerUsers/$(uid));
    }

    function isUser(uid) {
      return userDoc(uid).exists();
    }

    function isPartner(uid) {
      return partnerUserDoc(uid).exists() &&
             partnerUserDoc(uid).data.userType == 'partner';
    }

    function isAdmin(uid) {
      return partnerUserDoc(uid).exists() &&
             partnerUserDoc(uid).data.isAdmin == true;
    }

    /** =====================
     * üë§ USERS
     * ===================== **/
    match /users/{userId} {
      // User can manage their own user doc
      allow read: if request.auth != null;
      allow write, update, delete: if request.auth != null && request.auth.uid == userId;

      // ‚ö†Ô∏è TEMPORARY: Allow updating onboardingStatus for migration
      // TODO: Remove this after migration is complete
      allow update: if request.auth != null 
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['onboardingStatus', 'updatedAt'])
        && request.resource.data.onboardingStatus in ['not_started', 'completed', 'skipped'];

      // User coupons: users/{userId}/coupons/{couponId}
      match /coupons/{couponId} {
        allow create, read, update, delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    /** =====================
     * üëî PARTNER USERS
     * ===================== **/
    match /partnerUsers/{partnerId} {
      // Allow rule engine to fetch partnerUser doc when checking admin status
      allow get: if request.auth != null;

      // Partner can read/update their own record
      allow read, update: if request.auth != null && request.auth.uid == partnerId;

      // Create own partner record (from invite)
      allow create: if request.auth != null
        && request.auth.uid == partnerId
        && request.resource.data.userType == 'partner'
        && request.resource.data.createdFromInvite is string;

      // No client deletes
      allow delete: if false;

      /** =======================
       * üéü COUPONS SUBCOLLECTION
       * ======================= **/
      match /coupons/{couponId} {
        // ‚úÖ Partner can manage their own coupons
        allow read, write: if request.auth != null && request.auth.uid == partnerId;

        // ‚úÖ Users can create (generate) coupons for a partner
        allow create: if request.auth != null
          && request.resource.data.userId == request.auth.uid  // coupon belongs to this user
          && request.resource.data.partnerId == partnerId      // coupon linked to this partner
          && request.resource.data.keys().hasAll(['userId', 'partnerId', 'code', 'status', 'createdAt']);

        // ‚úÖ User can read their own coupon
        allow read: if request.auth != null
          && request.auth.uid == resource.data.userId;

        // üö´ Prevent deletes
        allow delete: if false;
      }
    }

    /** =====================
     * üéØ GOALS
     * ===================== **/
    match /goals/{goalId} {
      allow read: if request.auth != null;

      allow create: if request.auth != null
        && request.auth.uid == request.resource.data.userId;

      allow update, delete: if request.auth != null
        && request.auth.uid == resource.data.userId;

      // Nested sessions
      match /sessions/{sessionId} {
        allow read, write, update, delete: if request.auth != null
          && request.auth.uid == get(/databases/$(database)/documents/goals/$(goalId)).data.userId;
      }

      // Nested hints (per-goal)
      match /hints/{hintId} {
        allow read, write, update, delete: if request.auth != null
          && request.auth.uid == get(/databases/$(database)/documents/goals/$(goalId)).data.userId;
      }
    }

    /** =====================
     * üß© GOAL SESSIONS (alt structure)
     * ===================== **/
    match /goalSessions/{goalId} {
      allow read: if request.auth != null;

      match /sessions/{sessionId} {
        allow read, write, update, delete: if request.auth != null
          && request.auth.uid == get(/databases/$(database)/documents/goals/$(goalId)).data.userId;
      }
    }

    /** =====================
     * üéÅ EXPERIENCE GIFTS
     * ===================== **/
    match /experienceGifts/{giftId} {
      allow read, write: if request.auth != null;
    }

    /** =====================
     * üí° HINTS (flat collection)
     * ===================== **/
    match /hints/{hintId} {
      allow read, write: if request.auth != null;
    }

    /** =====================
     * üëØ FRIEND REQUESTS
     * ===================== **/
    match /friendRequests/{requestId} {
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.senderId ||
         request.auth.uid == resource.data.recipientId);

      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.senderId;

      allow update, delete: if request.auth != null &&
        (request.auth.uid == resource.data.recipientId ||
         request.auth.uid == resource.data.senderId);
    }

    /** =====================
     * üë¨ FRIENDS
     * ===================== **/
    match /friends/{friendDocId} {
      // Allow both read and delete if user is part of the friendship
      allow read, delete: if request.auth != null
        && (request.auth.uid == resource.data.userId || request.auth.uid == resource.data.friendId);

      // Allow creating either direction
      allow create: if request.auth != null
        && (request.auth.uid == request.resource.data.userId || request.auth.uid == request.resource.data.friendId);

      // Optional: Allow updates only for status fields, if you add them later
      allow update: if request.auth != null
        && (request.auth.uid == resource.data.userId || request.auth.uid == resource.data.friendId);
    }


    /** =====================
     * üîî NOTIFICATIONS
     * ===================== **/
    match /notifications/{notificationId} {
      allow read, update, delete: if request.auth != null &&
        request.auth.uid == resource.data.userId;
      allow create: if request.auth != null;
    }

    /** =====================
     * üåç EXPERIENCES (public)
     * ===================== **/
    match /experiences/{experienceId} {
      allow read: if true;
      allow write: if request.auth != null;
    }

    /** =========================================================
     * üíå PARTNER INVITES
     * ========================================================= **/
      match /partnerInvites/{inviteId} {
        allow read: if true;

        allow create: if request.auth != null
          && get(/databases/$(database)/documents/partnerUsers/$(request.auth.uid)).data.isAdmin == true
          && get(/databases/$(database)/documents/partnerUsers/$(request.auth.uid)).data.userType == 'partner'
          && request.resource.data.status == 'pending'
          && request.resource.data.createdBy == request.auth.uid
          && (
            !('createdByEmail' in request.resource.data)
            || request.resource.data.createdByEmail is string
            || request.resource.data.createdByEmail == null
          )
          && request.resource.data.keys().hasOnly([
            'status', 'createdAt', 'createdBy', 'createdByEmail'
          ]);

        allow update, delete: if request.auth != null
          && get(/databases/$(database)/documents/partnerUsers/$(request.auth.uid)).data.isAdmin == true;
      }




    /** =========================================================
     * üßæ LEGACY partnerCoupons/{partnerId}/coupons
     * ========================================================= **/
    match /partnerCoupons/{partnerId} {
      match /coupons/{couponId} {
        // Partner can read their own (legacy)
        allow read: if request.auth != null &&
          request.auth.uid == partnerId &&
          isPartner(request.auth.uid);

        // Partner can update only specific fields
        allow update: if request.auth != null &&
          request.auth.uid == partnerId &&
          isPartner(request.auth.uid) &&
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['status', 'redeemedAt']);

        // No client create/delete
        allow create, delete: if false;
      }
    }
  }
}
